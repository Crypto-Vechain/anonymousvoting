# VeChain匿名投票合约
VeChain匿名投票合约是一个基于密码学理论构建的利用智能合约实现的多方匿名投票方案。该方案具有如下性质：

1. 去中心化：该投票方案需要名义上的第三方存在，不过该方只作为组织方，可自愿选择是否参与投票。如果参与投票，在投票过程中并无额外信息获取等特权。
2. 自动计票：该方案在所有投票人投票结束后可以自动计票，该过程公开进行，理论上可以让任何人在投票结束后的任何时间获得正确的投票结果。
3. 隐私性：该投票方案可以在最大程度上保护投票人的隐私。对于半可信模型，敌手无法获取与投票人相关的任何保密信息。

## 使用流程
### 1. 合约部署
VeChain匿名投票方案中用到两个合约：`LocalCrypto`用于离线计算，投票人将自行利用该合约生成选票相关的参数用以提交；`AnonymousVoting`用于在线交互，用户注册、提交承诺和选票等过程都需要与该合约进行交互。
在投票开始前，该合约将被部署。系统自动默认部署合约的地址为管理员。管理员在投票过程中起到推进进程的作用，理论上不能获得额外的信息优势。

部署合约`AnonymousVoting`时需要提供两个参数：  
1. `gap`：一个整数，表示在投票中各个阶段的时间节点的最小间隔，单位为秒。比如设为1000后，管理员在启动投票时设置的承诺阶段结束时间（如果有承诺阶段）至少比投票阶段结束时间少1000秒。该时间间隔只对管理员在投票开始阶段设置参数时有效，后续用户的行为将受管理员设置的参数制约。（由于技术原因，目前投票系统暂不支持时间限制功能。）  
2. `address`：一个地址参数，该地址被认为是整个投票过程的管理员，管理员将推进投票的进程。

### 2. 启动阶段
投票开始阶段，由管理员组织设置相关参数。

第一步，管理员将预先设置白名单。白名单是一个由地址组成的集合，只有在白名单中出现的地址才有资格注册并参与到投票中。  
**调用方法**：```AnonymousVoting.setEligible(address[] addresses)```  
方法中的参数为地址的集合。  
**调试方法**：`AnonymousVoting.getEligible()`  
可查看当前白名单状态

第二步，管理员将启动投票，需要设置一些参数。  
**调用方法**：`AnonymousVoting.beginSetupUp(...)`  

方法中有8个参数：  

1. `_question`：字符串类型，表示投票名称。  
2. `enableCommitmentPhase`：布尔类型，表示是否启用承诺。启用承诺可以提高安全性，不过过程将会相对复杂，两轮交互将增加至三轮。  
3. (3-7.) 整数类型，用于时间节点的设置。目前版本不支持时间节点，所以参数设置无效。只需保证参数间逐个递增，并保证相邻两项的差不小于合约部署阶段设置的gap。  
4. (8.) `_depositrequired`：整数类型，表示费用，作为管理员和所有参与投票方履行职责的保证。  
   同时，调用此方法需要设置value，大小和第8个参数相同。  

**调试方法**：`AnonymousVoting.getQuestion()`  
可查看投票名称，可用于观察投票是否被正常启动

### 3. 注册阶段
在注册阶段，投票参与方进行注册。投票人需要提交两个参数，用户的公钥$g^x$，以及证明自己身份（即证明自己知道私钥x）的零知识证明。这两部分数据的生成需要配合`LocalCrypto`使用。  

1. 公钥部分。这个公钥是用来投票的公钥，与智能合约以及区块链本身无关，是该投票系统中单独使用的公钥。这个公钥应该由投票人预先得知。公钥的形式为椭圆曲线上某一点的二维坐标形式，即如果系统验证改点位于椭圆曲线上即为一个合法公钥。为了方便投票人（其实是测试者，因为投票人应该私下生成公钥私钥，而不是通过合约得到）得到公钥，利用私钥$x$生成公钥$g^x$的方法在`LocalCrypto`中提供。  
**公钥生成调用方法**：`LocalCrypto.getMul(x)`  
其中`x`即为投票人私钥。
2. 零知识证明部分。下面我对相关理论问题进行简述，更加具体的内容将不会在这里展现。  
我们如何证明我们知道$g^x$对应的是$x$呢？理论上，我们需要使用一个随机数$v$（可以视为该证明的私钥，于是$g^v$可以被视为该证明的公钥），并给验证者提供一个数$r$作为证明，其中$r=v−x\cdot H(sender,g^x,g^v)$，其中H为任意hash函数，则验证者可以通过验证$g^v$和$g^r\cdot g^{x\cdot H(sender,g^x,g^v)}$是否相等来作为判断依据。  
**零知识证明调用方法**：`LocalCrypto.createZKP(x, v, xG[2])`  
其中`x`和`v`即为投票人私钥和零知识证明随机数，二元组`xG[2]`为投票人公钥$g^x$的笛卡尔形式坐标。方法将生成一个四元组`res[4]`。其中第一项`res[0]`即为上文中的零知识证明$r$，后三项为$g^v$的Jacobian形式坐标，这也是由于我们提交注册的接口是Jacobian形式的。  
这里还要注意的是，这次方法的调用和其他对于`LocalCrypto`方法的调用有所不同，由于零知识证明的生成过程中需要用到用户的地址作为Hash函数的参数，因此也需要保证自己的零知识证明是通过自己的地址发送的调用。  

**注册调用方法**：`AnonymousVoting.register(xG[2], vG[3], r)`  
参数分别为投票人公钥，零知识证明随机数对应的公钥，以及零知识证明。

### 4. 结束注册阶段
该阶段为管理员在所有用户注册结束后调用，用于生成每个人在投票过程当中使用的用于混淆自己投票内容保证隐私性的干扰项。方法只能由管理员调用，一经调用之后，每个用户可以通过相关的方法查询自己的干扰项（当然也可以通过一定的方式得知别人的干扰项，不过没有影响），并将利用与后面的票以及承诺（如果有）的生成。下面我将简述理论中干扰项的生成。  
理论中，每个人的干扰项是不同的，不过是通过相同的公式生成的。同时，生成干扰项的参数是每个参与方的公钥，这意味着两点：每个人都可以知道所有人的干扰项；理论上只有所有人共同合谋才能利用系统漏洞。我们将干扰项记为$g^y$。  
<!--我们将干扰项记为g^(y_i )=(∏24_(j=1)^(i−1)▒g^(x_j ) )/(∏24_(j=i+1)^n▒g^(x_j ) )=(g^(x_1 )…g^(x_(i−1) ))/(g^(x_(i+1) )…g^(x_n ) )-->
**结束注册阶段调用方法**：`AnonymousVoting.finishRegistrationPhase()`  
**投票人查询信息方法**：`AnonymousVoting.getVoter()`  
查询得到的信息是该交易或调用发起方的地址对应的投票人的信息。返回值为三部分：前两部分二元组的形式，分别为$g^x$和$g^y$的二维形式坐标；第三部分是投票人提交的承诺（如果以提交）。  
这里我要稍微解释一下有关问题：为什么我们理论中的表达式都是以幂的形式出现，而代码中通常是乘积？由于我们理论研究中，通常把群作为乘法群来看待；然而我们利用椭圆曲线的方式实现群，用加法群的方式更好理解。所以在代码中，`xG`、`yG`等对应的就是理论中的$g^x$，$g^y$。

### 5. 计算投票相关数据
所有投票人注册完毕，在第4阶段我们生成了投票人为了保护票面隐私需要使用的干扰项。到目前为止，所有投票准备工作完毕，投票人就可以进行投票了。当然，由于我们的方案利用了密码学的原理，不是简单的计票，因此目前我们需要进行一些手动操作来生成我们提交的内容。  
首先我介绍一下票面内容。我们需要提交票的加密结果，但是这是不够的。由于票是加密的，大家没有办法直观的了解投票人是不是投出了一个合法的票，因为加密会导致其他人无法判断投票人是合法的投票还是随便提交了一个结果破坏投票（由于我们方案的机制导致破坏结果并不会导致报错，只会让最终结果不可识别）。因此，我们还要额外提交一个零知识证明，证明我们投出的票面明文只会是0或1两种情况。当然还会提交一些辅助零知识证明的参数。  
加密的票：$y=g^(xy)\cdot g^v$.  
相关的零知识证明参数在这里暂时不详述。

简言之，投票需要提交的相关数据总共有14个，可以调用方法生成。  
**选票生成调用方法**：  
​	赞成票：`LocalCrypto.create1outof2ZKPYesVote(xG[2], yG[2], w, r, d, x)`  
​	反对票：`LocalCrypto.create1outof2ZKPNoVote(xG[2], yG[2], w, r, d, x)`  
其中`xG`为投票人公钥，`yG`为投票干扰项，`w`、`r`、`d`为生成该零知识证明的随机数，`x`为投票人私钥。该方法生成两组共14个数据，第一组10个数据，第二组4个数据。

如果管理员在投票发起阶段将是否开启承诺阶段设置为是，那么投票人在提交票之前需要提交一个承诺，保证之后投出的票和承诺相一致。  
**承诺生成调用方法**：  
`LocalCrypto.commitToVote(params[4], xG[2], yG[2], y[2], a1[2], b1[2], a2[2], b2[2])`  
其中`params`为选票生成的第二组对应的4个数据，`xG`、`yG`分别为投票人公钥和投票干扰项，后面5组共10个输入是两两分组的选票的第一组10个数据，按顺序排列。该方法生成的结果为一个hash值用于验证后续选票的合法性。
### 6. 提交承诺（可选）
在投票人私下得到选票的相关计算结果后，如果管理员开启了承诺阶段，则投票人将在此阶段将上面计算好的承诺提交给合约。  
**提交承诺调用方法**：`AnonymousVoting.submitCommitment(h)`  
其中`h`为承诺。
### 7. 提交选票
如果管理员开启了承诺阶段，则投票人将在所有投票参与方提交承诺后提交选票。如果没有开启承诺阶段，则投票人可以自由提交选票。  
**提交选票调用方法**：
​	`AnonymousVoting.submitVote(params[4], y[2], a1[2], b1[2], a2[2], b2[2])`  
其中这里所有的输入参数与第5阶段中生成承诺的同名参数可以一一对应。
### 8. 计票
我们的协议支持公开计票，不过合约可以自行计算投票结果供所有投票参与方自行查询，这个唱票过程可以由管理员进行触发。  
**触发唱票调用方法**：`AnonymousVoting.computeTally()`  
**查询计票结果调用方法**：`AnonymousVoting.getFinalTally()`，该方法返回所有投赞成票的人数。

## 局限

### 技术层面

1. 我们的方案目前不支持时间控制。这个问题目前正在解决。
2. 我们只支持二元投票，即只能投支持和反对票，而且只支持单一选项。这个问题可以转化为多个选项的选择，通过在群中选取两个生成元，分别投票和生成证明。正好的方案还在研究中。
3. 在同一个合约中，只能同时运行一个投票，尽管投票结束后可以重置并开始新的投票。这个问题目前不是研究重点。

### 理论层面

1. 该方案必须要求所有注册方都成功完成所有投票过程，即得到所有注册方的选票才能计算最终结果。如果有一个注册方放弃提交投票或提交承诺，投票将无条件终止，因为理论上已经无法得到正确结果。这个问题目前是理论难点。
2. 由于计票过程是暴力搜索，因此投票人数过多有可能导致计票时间过长。这个问题目前正在通过具有加法同态的加密方案进行尝试设计。